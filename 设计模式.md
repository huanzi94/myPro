设计模式

一、设计模式的概念：



二、设计模式的七大原则：

1、单一职责原则

		对于类而言，一个类应该只负责一个职责，如果一个A类负责两个职责：职责1和职责2，当职责1变动时，更改A类时可能会引起职责2发生改变。如果需要将A类拆分成两个类：A1类和A2类。

案例：

2、接口隔离原则

		一个可对接口的依赖应该建立在最小接口依赖原则之上，也就是说，如果A类依赖B接口，且A类中只需要使用B接口的一个方法，那么B接口中其他方法对于A类来说就是冗余的。此时，要需要将B接口进行拆分成C接口和B接口，在C接口中创建A类中需要的那个方法，然后让A、B分别依赖C接口。

3、依赖倒转原则（依赖倒置原则）

- 高层模块不能依赖底层模块，两者都应该依赖顶层。
- 抽象不能依赖细节，细节应该依赖抽象。
- 依赖倒转（倒置）的中心思想就是面向接口编程。
- 依赖倒转（倒置）的设计理念是：抽象类出来的东西是相对稳定的东西，细节上的东西相对具多变性。以抽象为基础搭建的框架，要比以细节为基础的框架要稳定的多，在java中抽象指的就是抽象类或者接口。
- 抽象类或者接口的目的就是制定好规范，但是却不涉及具体的操作，而是把细节上的实现交给它的实现类去完成。

4、里氏替换原则

- 继承关系中，凡是引用父类的地方都可以使用子类来替换。
- 继承关系中，子类尽量不要去重写父类已经实现了的方法，而是应该去重写父类中的抽象方法。
- 在合适的情况下，应该使用聚合、组合、依赖的方式来替换继承。

5、开闭原则（ocp原则）

    开闭原则是最基础的原则，所有的原则都是为了实现了开闭原则而设计。 

- 模块或者函数应该对扩展（提供方）开放，对修改（使用方）关闭。
- 在软件需求变化时，尽量通过扩展来实现，而不是通过修改已有的代码来实现。也就是用抽象构建框架，用实现来扩展细节。

6、迪米特法则（最少知道原则）

- 一个类应该让其他对象对其保持最少了解原则，也就是说，该类应该提供一个public的方法，而不应该暴露自己是如何实现的。
- 迪米特法则简单的说，就是只与其直接朋友通信。
  - 朋友：两个类之间有耦合关系，那么这两个类之前就存在朋友关系，耦合的分类有多种：依赖、关联、组合、聚合等。
  - 直接朋友：一个类如果出现在另外一个类的成员变量、方法参数、方法返回值等地方，那么这两个类就称为直接朋友关系。如果出现在局部变量位置，那么这个类就不是直接朋友关系，也就是说，局部变量最好不要出现在局部变量的位置。

7、合成复用原则

   尽量使用合成或者聚合的方式，而不是使用继承的方式。





设计模式的七大原则总结：

- 对程序中可变的地方独立出来，不要和不变的地方混杂在一起。
- 面向接口编程，而不是面向实现编程。
- 尽量让对象之间的设计满足低耦合，高内聚原则。

三、设计模式

	设计模式总共可以分为三种类型，共23种模式。

一 创建型模式（共4种）：

1、单例模式

	

3.1.1.1、类变量写法

     如果确定这个实例一定会用到，那么这种写法是最完美的，不用担心线程安全问题。

    public class Singletion01 {
    
        private Singletion01() {
        }
    
        private final static Singletion01 singletion01 = new Singletion01();
    
        public static Singletion01 getInstance() {
            return singletion01;
        }
    }

3.1.1.2、静态内部类写法

      静态内部在外部类加载的时候，不会被加载，只有在调用getInstance()方法用到InnerClass时，才会被加载，做到了懒加载。其次类加载是线程安全的，所以也保证了是线程安全的。

    public class Singletion02 {
    
        private Singletion02() {
        }
    
        public static Singletion02 getInstance() {
            return InnerClass.singletion01;
        }
    
        private static class InnerClass {
            private final static Singletion02 singletion01 = new Singletion02();
        }
    }

3.1.1.3、DCL写法

     DCL(双重检查锁)写法，是目前单例最常用的写法。好多地方都是用DCL实现的单例模式。

    public class Singletion03 {
        
        private static volatile Singletion03 singletion03 = null;
    
        private Singletion03() {
        }
    
        public static void main(String[] args) {
            System.out.println(Singletion03.getInstance().hashCode());
        }
    
        public static Singletion03 getInstance() {
            if (singletion03 == null) {
                synchronized (Singletion03.class) {
                    if (singletion03 == null) {
                        singletion03 = new Singletion03();
                    }
                }
            }
            
            return singletion03;
        }
    }

单例模式的在JDK中的应用：

- java.lang.Runtime，实际上应用的就是类变量的方式实现的单例模式。



2、工厂模式

	工厂模式将创建对象的方式对客户端隐藏起来，客户需要创建对象，只需要告诉工厂类对象的类型即可，关于对象是如果创建的，并不关心。工厂模式需要提供一个接口，由其子类实现该工厂接口，最终由子类来决定创建哪一个工厂类对象。

案例：

    假如画图功能，要求根据不同的类型，画出不同的图形。

应用场景：

- 日志记录器。

3.1.2.1、简单工厂模式

   在工厂类内部进行列举判断，根据传入的对象的类型来获取到对应的工厂类的实例。

案例角色分析：

- Shape：图形接口，定义图形的规则。
- CircleShape/TriangleShape：图形接口的实现，定义了具体的图形。
- ShapeFactory：创建图形的工厂类，决定创建哪种图形对象。

类图：



编码：





3.1.2.2、工厂方法模式

	工厂方法模式将创建产品的任务下发到具体的产品对应的工厂类去实现。而最顶级的工厂类只是定义实现产品的规则，具体如何实现，交给产品对应的子类工厂去处理。

角色分析：

- Product：抽象产品类，定义产品的规则。
- ConcreteProduct：抽象产品类的实现类，具体定义产品的实现规则。
- Factory：抽象工厂类，描述创建工厂的规则。
- ConcreateFactory：抽象工厂类的实现类，定义创建某个产品的规则，一个实现类对应一种产品。

案例角色分析：

- Shape：图形接口，定义图形的规则。
- CircleShape/TriangleShape：图形接口的实现，定义了具体的图形。
- ShapeFactory：创建图形的顶级工厂类，定义创建某个产品的规则。决定创建哪种图形对象。
- CircleShapeFactory/TriangleShapeFactory：顶级工厂类的实现类，对应具体的某一个产品，由该实现类创建对应的产品。

类图：



编码：



源码分析：

3.1.2.3、抽象工厂模式

  抽象工厂模式要求有一个顶级的抽象工厂类，定义获取工厂对象的规则。

角色分析：

- Product：抽象产品类，定义产品的规则。
- ConcreteProduct：抽象产品类的实现类，具体定义产品的实现规则。
- AbstractFactory：顶级抽象工厂类，描述创建工厂的规则。
- ConcreateFactory：顶级抽象工厂类的实现类，定义创建某个产品的规则，一个实现类对应一种产品。
- GenerateFactory：获取对应的具体工厂类对象。

案例角色分析：

- Shape：图形接口，定义图形的规则。
- CircleShape/TriangleShape/OtherShape：图形接口的实现，定义了具体的图形。
- ShapeFactory/OtherFactory：创建图形的工厂类，定义创建具体对象的规则。
- AbstractShapeFactory：顶级抽象工厂类，用于定义创建工厂的规则。
- GenerateFactory：获取对应的具体工厂类对象。

类图：



编码：



工厂模式的在JDK中的应用：

- java.util.Calendar，实际上应用的就是简单工厂模式。




3、 原型模式

原型模式代表根据一个已有的对象，创建它的克隆对象，克隆对象和原对象拥有相同的属性和行为。克隆对象有两种方式，一种是深拷贝，通过实现Serializable接口实现，一种是浅拷贝，通过重写Object类的clone()方法实现，需要实现Cloneable。

角色分析：

- Prototype：原型类，定义一个已经存在的对象。
- Cloners：从已经定义好的原型类拷贝获得。

案例：

克隆羊的实现。

案例角色：

- Sheep：羊接口，定义羊的规则，羊的原型。
- ClonersSheepA/ClonersSheepB：Sheep的克隆对象。

实现：

- 深拷贝--重写clone()方法
  编码：
  
  
- 深拷贝--序列化/反序列方法
  编码：



原型模式的在Spring中的应用：

- Spring框架中的doGetBean()方法中用到了原型模式创建Bean。




4、建造者模式

建造者模式将一个产品的制作过程和产品独立出来，通过一步一步制作出来一个产品。这样可以使得同一套制作流程可以制作出来不同的产品。

角色分析：

- Builder：建造者类，抽象层，定义建造产品需要的步骤。
- ConcreateBuilder：建造者的实现类，用户具体定义建造产品的步骤。
- Produt：产品类，定义产品的属性。
- Director：指挥者，用于指定产品的指定流程。

案例：

	肯德基套餐。比如有汉堡加可乐套餐，汉堡有鸡肉汉堡，牛排汉堡。可乐有百事可乐，可口可乐。

案例角色：

- Hamburg：汉堡类，定义汉堡的属性。
- ChickenHamburgers/BeefHamburgers：具体的汉堡。
- Drink：饮料，定义饮料的属性。
- Pepsi/Coke：具体的饮料。
- KFCBuilder：肯德基制造者。
- BeefPepsiKFCBuilder/ChickenCokeKFCBuilder：实现KFCBuilder抽象类，定义具体的牛肉百事可乐套餐/鸡肉可口可乐套餐建造者。
- KFCDirector：肯德基套餐指挥者。

编码：



建造者模式的在Spring中的应用：

- Spring框架中的doGetBean()方法中用到了原型模式创建Bean。


二 结构型模式（共8种）：

1、适配器模式

3.2.1.1、类适配器



3.2.1.2、对象适配器



3.2.1.3、接口适配器



2 、桥接模式

桥接模式将抽象层和实现层分开，使得二者可以独立变化。在桥接模式中，最关键的部分是抽象层依赖于实现层。

案例：

​	假如有一个画图功能，有图形的抽象定义和画图的接口实现两部分组成。

角色分析：

- Abstraction：抽象层接口，定义抽象层角色的属性规则。
- RefinedAbstraction：抽象层接口的实现，重新定义了抽象层角色的属性规则。
- Implementor：实现层接口，定义实现层角色的行为规则。
- ConcreteImplementor：实现层接口的具体实现。重新定义了实现层角色的行为规则。

案例角色:

- Shape：图形的抽象层定义。
- RefinedShape：图形的抽象层定义的实现，重新定义了图形的行为规则。
- DrawShape：画图行为的接口定义。
- CircleDrawShape/TriangleDrawShape：画图行为的接口定义的具体实现，分别实现了画圆形和三角形。

类图：



编码：



源码分析：



3、装饰者模式



4、组合模式



5、外观模式



6、享元模式



7、代理模式



8、过滤器模式

三 行为型模式（共11）：

1、模板模式



2、命令模式



3、访问者模式



4、迭代器模式



5、观察者模式



6、中介者模式



7、备忘录模式



8、解释器模式

解释器模式的在Spring中的应用：

- Spring框架中的SpelExpressionParser类（SpEL解析器）使用的就是解释器模式。



9、状态模式



10、策略模式

策略模式的在JDK中的应用：

- Arrays工具类中的sort(T[] a, Comparator<? super T> c)使用的就是策略模式。



11、责任链模式（职责链模式）




