设计模式

一、设计模式的概念：



二、设计模式的七大原则：

1、单一职责原则

		对于类而言，一个类应该只负责一个职责，如果一个A类负责两个职责：职责1和职责2，当职责1变动时，更改A类时可能会引起职责2发生改变。如果需要将A类拆分成两个类：A1类和A2类。

案例：

2、接口隔离原则

		一个可对接口的依赖应该建立在最小接口依赖原则之上，也就是说，如果A类依赖B接口，且A类中只需要使用B接口的一个方法，那么B接口中其他方法对于A类来说就是冗余的。此时，要需要将B接口进行拆分成C接口和B接口，在C接口中创建A类中需要的那个方法，然后让A、B分别依赖C接口。

3、依赖倒转原则（依赖倒置原则）

- 高层模块不能依赖底层模块，两者都应该依赖顶层。
- 抽象不能依赖细节，细节应该依赖抽象。
- 依赖倒转（倒置）的中心思想就是面向接口编程。
- 依赖倒转（倒置）的设计理念是：抽象类出来的东西是相对稳定的东西，细节上的东西相对具多变性。以抽象为基础搭建的框架，要比以细节为基础的框架要稳定的多，在java中抽象指的就是抽象类或者接口。
- 抽象类或者接口的目的就是制定好规范，但是却不涉及具体的操作，而是把细节上的实现交给它的实现类去完成。

4、里氏替换原则

- 继承关系中，凡是引用父类的地方都可以使用子类来替换。
- 继承关系中，子类尽量不要去重写父类已经实现了的方法，而是应该去重写父类中的抽象方法。
- 在合适的情况下，应该使用聚合、组合、依赖的方式来替换继承。

5、开闭原则（ocp原则）

    开闭原则是最基础的原则，所有的原则都是为了实现了开闭原则而设计。 

- 模块或者函数应该对扩展（提供方）开放，对修改（使用方）关闭。
- 在软件需求变化时，尽量通过扩展来实现，而不是通过修改已有的代码来实现。也就是用抽象构建框架，用实现来扩展细节。

6、迪米特法则（最少知道原则）

- 一个类应该让其他对象对其保持最少了解原则，也就是说，该类应该提供一个public的方法，而不应该暴露自己是如何实现的。
- 迪米特法则简单的说，就是只与其直接朋友通信。
  - 朋友：两个类之间有耦合关系，那么这两个类之前就存在朋友关系，耦合的分类有多种：依赖、关联、组合、聚合等。
  - 直接朋友：一个类如果出现在另外一个类的成员变量、方法参数、方法返回值等地方，那么这两个类就称为直接朋友关系。如果出现在局部变量位置，那么这个类就不是直接朋友关系，也就是说，局部变量最好不要出现在局部变量的位置。

7、合成复用原则

   尽量使用合成或者聚合的方式，而不是使用继承的方式。





设计模式的七大原则总结：

- 对程序中可变的地方独立出来，不要和不变的地方混杂在一起。
- 面向接口编程，而不是面向实现编程。
- 尽量让对象之间的设计满足低耦合，高内聚原则。

三、设计模式

	设计模式总共可以分为三种类型，共23种模式。

一 创建型模式（共4种）：

1、单例模式

	

3.1.1.1、类变量写法

     如果确定这个实例一定会用到，那么这种写法是最完美的，不用担心线程安全问题。

    public class Singletion01 {
    
        private Singletion01() {
        }
    
        private final static Singletion01 singletion01 = new Singletion01();
    
        public static Singletion01 getInstance() {
            return singletion01;
        }
    }

3.1.1.2、静态内部类写法

      静态内部在外部类加载的时候，不会被加载，只有在调用getInstance()方法用到InnerClass时，才会被加载，做到了懒加载。其次类加载是线程安全的，所以也保证了是线程安全的。

    public class Singletion02 {
    
        private Singletion02() {
        }
    
        public static Singletion02 getInstance() {
            return InnerClass.singletion01;
        }
    
        private static class InnerClass {
            private final static Singletion02 singletion01 = new Singletion02();
        }
    }

3.1.1.3、DCL写法

     DCL(双重检查锁)写法，是目前单例最常用的写法。好多地方都是用DCL实现的单例模式。

    public class Singletion03 {
        
        private static volatile Singletion03 singletion03 = null;
    
        private Singletion03() {
        }
    
        public static void main(String[] args) {
            System.out.println(Singletion03.getInstance().hashCode());
        }
    
        public static Singletion03 getInstance() {
            if (singletion03 == null) {
                synchronized (Singletion03.class) {
                    if (singletion03 == null) {
                        singletion03 = new Singletion03();
                    }
                }
            }
            
            return singletion03;
        }
    }

单例模式的在JDK中的应用：

- java.lang.Runtime，实际上应用的就是类变量的方式实现的单例模式。



2、工厂模式

3.1.2.1、简单工厂模式



3.1.2.2、工厂方法模式



3.1.2.3、抽象工厂模式



工厂模式的在JDK中的应用：

- java.util.Calendar，实际上应用的就是简单工厂模式。





3、 原型模式



- 深拷贝--重写clone()方法
  
- 深拷贝--序列化/反序列方法



原型模式的在Spring中的应用：

- Spring框架中的doGetBean()方法中用到了原型模式创建Bean。



4、建造者模式



二 结构型模式（共8种）：

1、适配器模式

3.2.1.1、类适配器



3.2.1.2、对象适配器



3.2.1.3、接口适配器



2 、桥接模式





3、装饰者模式



4、组合模式



5、外观模式



6、享元模式



7、代理模式



8、过滤器模式

三 行为型模式（共11）：

1、模板模式



2、命令模式



3、访问者模式



4、迭代器模式



5、观察者模式



6、中介者模式



7、备忘录模式



8、解释器模式

解释器模式的在Spring中的应用：

- Spring框架中的SpelExpressionParser类（SpEL解析器）使用的就是解释器模式。



9、状态模式



10、策略模式

策略模式的在JDK中的应用：

- Arrays工具类中的sort(T[] a, Comparator<? super T> c)使用的就是策略模式。



11、责任链模式（职责链模式）




