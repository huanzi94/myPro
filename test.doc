深入理解java虚拟机
1	常见的java虚拟机（JVM）：
1.1	Sun HotSpot VM
HotSpot是Sun/Oracle JDK 和 OpenJDK 中默认的虚拟机，是目前应运最为广泛的虚拟机，使用java –version来查看JDK版本信息：
C:\Users> java -version
java version "1.8.0_171"   # 如果是openJDK, 则这里会显示：openjdk version
Java(TM) SE Runtime Environment (build 1.8.0_171-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode) # 使用的是HotSpot虚拟机，默认为服务端模式
1.2	IBM J9
目前最具影响力的三大虚拟机之一。
1.3	Taobao VM
 国内的一款虚拟机，由淘宝公司开发。
2	java虚拟机内存结构：
java虚拟机内存结构大致由方法区、堆、虚拟机栈、本地方法栈、程序计数器部分组成。其中方法区和堆属于线程共享区，虚拟机栈、本地方法栈和程序计数器属于线程私有区。
 
2.1	方法区：一般存放被虚拟机加载的类信息（类的版本，字段，方法，接口），常量，静态常量，即时编译后的代码信息等。
2.2	堆：一般对象的实例就是在堆上分配内存，它是虚拟机管理的最大的一块内存区域，也是GC最主要的区域。JAVA堆可以处于不连续的内存空间，但是逻辑上是连贯的。
2.3	虚拟机栈：java方法执行的所用到的区域，每个方法执行都会创建一个栈帧，栈帧用于存放局部变量表，操作数栈，方法出口等信息。方法的从调用到执行完毕的过程就是栈帧在虚拟机栈中入栈到出栈的过程。当一个线程所请求的栈的深度大于虚拟机所允许的最大深度，就会抛出StackOverflowException。如果虚拟机栈能动态扩展内存，在申请内存时无法申请到足够的内存空间，则会抛出OutOfMemoryException。
2.4	本地方法栈：本地方法栈和虚拟机栈一样都是方法执行所用到的区域，不过，本地方法栈执行的是一些Native方法。
Native方法指的是：
（1）java类中的方法被native关键字修饰，类似于abstract修饰的方法一样，只有方法签名，没有具体实现。主要用于加载文件和动态链接库，比如java无法访问操作系统的底层信息，这时就必须使用C语言来实现访问操作系统底层信息的代码，也就是被native修饰的方法可以被C语言重写。
（2）实现步骤：
a、Java程序中声明native修饰的方法，类似于abstract修饰的方法，只有方法签名，没有方法实现。编译该java文件，会产生一个.class文件。
b、使用javah编译上一步产生的class文件，会产生一个.h文件。
c、.cpp文件实现上一步中.h文件中的方法。
d、.cpp文件编译成动态链接库文件.dll。
e、最用System或是Runtime中的loadLibrary()方法加载上一步的产生的动态连接库文件了。
2.5	程序计数器：程序计数器是程序执行的信号指示器。Java虚拟机在执行代码过程中，字节码解释器通过更改程序计数器的值来确定接下来执行哪一条指令。
3	Java对象
在java中，万物皆对象。在应运中对象是类的一个实例，指的是一个具体的东西。比如定义一个动物类，那么对象可以是具体的某个动物，比如猫。
3.1	对象的创建
3.1.1	使用new关键字创建对象
Record rr4 = new Record();
3.1.2	使用Class.forName()加载类，然后通过newInstance()获取类的实例或者先获取类的构造方法，通过构造器的newInstance()获取类的实例。
Class record = Class.forName("testDemo.Record");
// 直接通过newInstance()获取类的实例
Record re = (Record) record.newInstance();
System.out.println(re instanceof Record);

// 先获取类的构造器
Constructor con = record.getConstructor();
// 通过类的构造器获取类的实例
Record re1 = (Record) con.newInstance();
3.1.3	实现Clonable接口并重写clone()方法，调用clone()方法创建类的实例。
class Record implements Cloneable{
@Override
protected Object clone() throws CloneNotSupportedException {
    return super.clone();
}
}
Record rr2 = new Record();
Record rr3 = (Record) rr2.clone();
3.1.4	利用反序列化机制创建对象
	序列化主要用到FileOutputStream和ObjectOutputStream两个类，主要是将某个对象转化成字节的数据，写出到磁盘上，所以FileOutputStream用来连接磁盘文件，ObjectOutputStream将文件写到文件上。
CurvedCounterStatModel curvedCounterStatModel = new CurvedCounterStatModel();
try (ObjectOutputStream objOut = new ObjectOutputStream(new FileOutputStream("curve.model"))) {
    objOut.writeObject(curvedCounterStatModel);
} catch (IOException e) {
    e.printStackTrace();
}

	反序列化主要用到FileInputStream和ObjectInputStream两个类，将序列化写出的文件读取进来，转化成可用的对象。
try (ObjectInputStream obj = new ObjectInputStream(new FileInputStream("curve.model"))) {
    CurvedCounterStatModel curved = (CurvedCounterStatModel) obj.readObject();
} catch (IOException e) {
    e.printStackTrace();
}
注意：被序列化的类需要实现Serializablejie接口，告诉JVM，该类可以被序列化和反序列化。
补充内容：
	如果被序列化的对象的成员变量包含引用数据类型，序列化的时候，引用数据类型的成员也会被一起被序列化，如果该成员变量还有引用成员变量，那么也会一起序列化，但是这些变量也要实现Serializable接口，否则会报错，这个过程中的序列化的过程是自动的。如果确实包含了不想被序列化的变量，那么使用关键字transient修饰即可，序列化的时候，会跳过transient修饰的变量。
	如果父类实现了Serializable接口的话，因为继承关系，其子类也会编译成可被序列化的。
	对象的序列化是为了保护对象的成员变量，所以序列化的时候，不会调用对象的构造函数，因为调用构造函数也就是改变了对象的成员变量。
	对象的序列化是为了保护对象的成员变量，所以序列化的时候，其静态变量也不会被序列化。
3.2	对象分配内存
3.2.1	指针碰撞
假如堆内存空间连续，使用的空间占一半，未使用的内存空间占一半，中间使用一个指针指向零界点，当做指示器，当需要给对象分配内存的时候，就把指示器向未使用的内存空间移动对象大小个单位。
3.2.2	空闲列表
假如堆内存空间不连续，这时候需要维护一个内存列表来保存内存使用情况，当需要给对象分配内存时，就去内存列表中找一块内存分配给该对象，这个内存列列表称之为空闲列表。
	堆内存是否连续，取决于垃圾回收策略，虚拟机会根据垃圾回收器的回收策略来决定使用哪种内存分配方式。
3.3	对象的结构
 
3.3.1	对象头
	_mark: 用于存储对象的运行时数据，例如：对象的Hashcode、GC的分代年龄、线程持有的锁、锁状态标志、偏向时间戳等，官方称之为“Markword”。
	_kass: 用来存放对象所属class的指针，虚拟机通过这个来确认对象属于哪个类的实例。
	_length: 对象数组独有，用来存放对象数组的长度。
3.3.2	实际数据
对象的实际数据中存储的是对象实际定义的各种数据，包自身定义的各种类型的数据，也包括从父类中继承下来的内容。
3.3.3	对齐填充
对齐填充这部分内容可有可无，没有实际上的意义，实际是起到一个占位符的作用。因为Hstpot VM要求对象大小必须是8字节的整数倍，而对象头正好是8字节的倍数，所以剩下的实际数据要是不够8字节的整数倍的时候，就需要从padding中补齐。
3.4	对象的访问
3.4.1	句柄访问
使用句柄访问的方式，会在java堆上开辟出一条内存空间，用来存放句柄信息，称之为句柄池，句柄池中存放的是对象实例数据的地址信息和对象类型数据的地址信息。
 
3.4.2	直接指针访问
如果是使用指针访问的方式，reference中存储的就是对象的地址（hotspot就是用的这种方式）。
优缺点：
	句柄的方式访问，reference中存储就是固定的句柄信息，在对象被移除或者被GC后，只需要改变句柄中实际数据的指针即可，而reference本身不需要修改。
	直接指针的方式访问，优势就是访问速度快，它节省了每次指针定位的开销（句柄池中指针的定位），因为java中对象的访问时很频繁的。
4	垃圾回收
4.1	垃圾回收算法
4.1.1	标记-清除算法
这是最基础的回收算法，分“标记”和“清除”两个过程，首先标记出需要被回收的对象，然后再统一进行回收。
 
	缺点：
		效率问题：“标记”和“清除”两个过程的效率都很低。
		空间问题：标记清除算法回收完的内存空间不是连续的，后续再分配大对象时，可能会因找不大一块连续的足够的内存空间，而导致再触发一次垃圾回收。
4.1.2	复制算法
内存被分为一块大的Eden区域和两块相等的Survivor区域，每次使用其中的Eden区域和一块Survivor区域。当需要回收时，复制算法将Eden区域和使用的那块Survivor区域中还存活的对象一起复制到另外一块空闲的Survivor区域中（如果该Survivor区域空间不够存放这些对象，那么就需要向老年代借内存，剩余的内存将会通过内存担保进入老年代），然后清理掉Eden区域和刚才用过Survivor区域。清理完成后，Eden区域和刚刚放入存活对象的Survivor区域继续作为可用内存使用，被回收的Survivor区域作为空闲区域，留作下次回收使用。
 
4.1.3	分代回收算法
根据新生代对象“朝生夕死”，存活率低和老年代的对象存活高的特点，采用分代回收的算法。新生代因对象存活率低可以使用复制算法回收，老年代因对象的存活率高可使用标记-清除算法或者标记-整理算法回收。
4.1.4	标记-整理算法
标记-整理算法和标记-清除算法一样，只是标记-整理算法在标记过后不会立马清除，而是将可用存活对象向一边移动，之后将存活对象边界之外的区域全部回收。
 
4.2	垃圾回收器
4.2.1	Serial收集器（+XX:UseSeroalGC）
Serial收集器是一个串行收集器，也是一个单线程收集器。也就是一次只能使用一个CPU或者一个线程去进行垃圾回收，并且在进行垃圾回收的过程中，必须停掉所有的线程，直到垃圾回收工作结束。Serial收集器简单，没有线程交互的开销，是虚拟机Client模式下默认的垃圾收集器。
Serial收集器新生代采用的是“复制算法”，老年代采用的是“标记-整理”算法。
运行过程如下：
 
4.2.2	CMS收集器（-XX:+UseConcMarkSweepGC）
VM参数：
-XX:+UseCMSCompactAtFullCollection：控制CMS执行完Full GC后，进行一次碎片在整理过程。
 -XX:CMSFullGCsBeforeCompaction=2：控制CMS执行完几次不带压缩的Full GC后，进行一次压缩的Full GC。
CMS收集器是一款以“获取最短回收停顿时间”为目的的垃圾收集器，对于这种要求高响应速度的系统或者网站，CMS是很好的选择。CMS收集器是基于“标记-清除”算法实现的。分四个步骤实现：
	初始标记：标记一次GC Roots能直接关联到的对象。需要暂停用户线程，但是暂停时间很短。
	并发标记：对对象进行可达性分析标记，这个过程是并发执行的，可以和用户线程要一起执行。
	重新标记：标记并发标记过程中，变动过的那些对象。需要暂停用户线程，但是暂停时间很短。
	并发清除：对标记过的对象，进行并发清除，可以和用户线程要一起执行。
运行过程如下：
 
CMS优点：并发收集，停顿时间短。
CMS缺点：
	由于并发执行，对资源特别敏感，这是并发的通病，会减少吞吐率（简单的说，就是单位时间内会减少客户端与服务端之间的数据交互）。
	由于采用“标记-清除”算法，收集完毕后，会产生空间碎片。当遇到给大对象分配内存的时候，就需要提前执行FULL GC。为了解决这个问题，CMS提供了一个“- XX:+UseCMSCompaceAtFullCollection”的开关参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。
	无法清除“浮动垃圾”，由于并发清除是和用户线程并发执行的，那么执行过程中用户线程又产生的垃圾将无法清除，当前GC任务已经无法处理，只能留在下一次GC任务中。
4.2.3	G1收集器（-XX:+UseG1GC）
G1收集器是目前最新的服务端收集器，具有以下特点：
	并行与并发：G1收集器能利用多CPU和多核的硬件优势，极大的缩短用户线程的停顿时间。
	分代收集：在G1收集器中依然保留了分代的概念，能独立并且采用不同的方式对新对象、存活了一段时间的对象和回收过多次的对象进行很好的处理。
	空间整理：G1收集器既有“标记-整理”算法实现的部分，又有“复制”算法实现的部分，这两种算法不管怎么样都不会产生空间碎片，垃圾回收后，能对内存空间很好的进行归整处理。
	可预测的停顿时间：
G1收集器分以下四个步骤执行：
	初始标记
	并发标记
	最终标记
	帅选回收
执行过程：
 
5	内存分配
5.1	优先在Eden上分配内存
设置以下几个vm参数：
-XX:+PrintGCDetails:：打印GC信息
-Xms20m：设置最小堆内存10m
-Xmx20m：设置最大堆内存20m
-Xmn10m：设置年轻代内存10m
 
因为Eden和Survivor默认情况下是8:1，所以Eden区域总共大小8m，两个Survivor区域各占1m，可以看出，4m的内存全部在eden区域上分配。
5.2	大对象直接进入老年代
增加以下参数：
-XX:PretenureSizeThreshold=3M：设置老年代大小为3m。
 
可以看出5m的内存直接在老年代上分配。
5.3	长期存活的对象进入老年代
增加以下参数:
-XX:MaxTenuringThreshold=1（默认15）：设置对象在新生代年龄为1的直接进入老年代
 
这里已经取消了设置限制老年代大小。发现在发生又一次GC后，对象直接进入了老年代。
5.4	对象年龄动态判断
Vm参数：
-XX:MaxTenuringThreshold=5：新生代对象进入老年代年龄阈值
为了更加灵活的分配内存，虚拟机并不是按照对象达到设定的年龄才进入老年代，如果虚拟机发现，Survivor区域中年龄相同的对象占了Survivor区域的一半或者年龄大于等于设置的年龄的对象正在进行GC，那么直接将这些年龄放入老年代。
5.5	空间分配担保
VM参数：
-XX:-HandlePromotionFailure：开启空间分配担保。
空间分配担保规则（以DK7为分界线不太准确）：
JDK7之后：这个参数就失效了，GC规则就按照一下方式处理：如果老年代的连续空间比新生代对象的总大小都大，或者说比本次需要晋升到老年代的对象的平均大小都大，就进行Minor GC，否则就进行Full GC。
JDK7之前：如果在发生Minor GC，虚拟机首先会检查老年代的连续空间是否大于新生代对象的总大小。
	如果大于：那么本次Minor GC是安全的。
	如果不大于：那么检查是否开启空间分配担保（-XX:-HandlePromotionFailure）：
	如果没有开启：则直接进行一次Full GC。
	如果开启了，则检查老年代的连续空间是否大于本次需要晋升到老年代的对象的平均大小
	如果大于：则尝试进行Minor GC，但是仍是不安全的。
	如果小于：则直接进行Full GC。
6	虚拟机工具
6.1	
7	性能调优
7.1	
8	类文件的结构
 
8.1	class文件结构
使用无符号和表来表示class文件，二进制文件中没有空格和换行，使得文件更加紧凑，节省了空间，提高了性能。例如：Main.class文件：
 
	魔数：class文件的前四个字节表示魔数，用来表示这个文件是不是虚拟机可以识别的class文件，而不是使用文件名后缀来识别。
 
	版本号：接下来四个字节表示版本号，分为主板号和次版本号
 
			主版本号（minor_version）：0x0000
			次版本号（major_version）：0x0034，转化为十进制是52。Jdk8的版本号就是52。
	常量池：接下来是常量池，常量池的数据是不固定的，所以会有一个u2类型的数据表示常量的数量计数（计数从1开始，其他计数从0开始）。0x000F翻译成十进制是16，表示有常量池中有16个常量，索引从1~15标识。
 
			
8.2	字节码指令
Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其后的零至 多个代表此操作所需参数(称为操作数，Operands)而构成。 操作码的长度为1个字节，因此最大只有256条，是基于栈的指令集架构。
 
如上图，相关指令的含义如下：
0: aload_0 // 
1: invokespecial #1 // Method java/lang/Object."<init>":()V，调用特殊的方法，比如初始化方法，私有方法，父类方法。
4: return // 返回
============ main方法开始============
0: iconst_1 // 将本地常量1（Main.java定义的a）加载到操作数栈中。
1: istore_1 // 将操作数栈中的1（对应的a）加载到局部变量表中。
2: iconst_1 // 将本地常量1（Main.java定义的b）加载到操作数栈中。
3: istore_2 // 将操作数栈中的1（对应的b）加载到局部变量表中
4: iload_1 // 将第一个变量从局部变量表加载到操作数栈中
5: iload_2 // 将第二个变量从局部变量表加载到操作数栈中
6: iadd // 把操作数栈的量的元素执行add操作（a+b）。
7: istore_3 // 将iadd计算的结果加载到局部变量表中。
8: return // 返回
8.3	字节码指令加载与数据类型
大多数指令包含了数据类型，比如iload表示将int类型的数据从操作数栈中加载到局部变量表中，其中i表示是对int类型数据进行操作，ｌ表示long，s表示short，b表示byte，c表示char，f表示 float，d表示double，a表示reference。



9	类加载机制
知识点：类的初始化过程（重要）
Student s = new Student();在内存中做了哪些事情?
•	加载Student.class文件进内存
•	在栈内存为s开辟空间
•	在堆内存为学生对象开辟空间
•	对学生对象的成员变量进行默认初始化
•	对学生对象的成员变量进行显示初始化
•	通过构造方法对学生对象的成员变量赋值
•	学生对象初始化完毕，把对象地址赋值给s变量
9.1	
10	虚拟机字节码执行引擎
11	VM通用参数
	+DisableExplicitGC进制虚拟机调用System.gc()。
	

